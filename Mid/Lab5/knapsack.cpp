#include<iostream>#include<iomanip>using namespace std;struct Item{	char id[5];	int weight;	int value;	float density;};void fractionalKnapsack(Item items[], int n, int w){	int i, wt;	float value;	float totalWeight = 0, totalBenefit = 0;	cout<<"Step 3:\n\n\tNow we need to pick items such that our benefit is maximum  and total weight of the selected is at most the limit."<<endl;	cout<<"\tNow check if the item's weight + total picked weight is less than the limit then we pick the item with it's total value."<<endl;	cout<<"\tIf not then we will faction it with the remaining weight and the corresponding value.\n"<<endl;	cout<<"Selected Items and Values after Calculation:\n\n\tItem\t\tWeight\t\tValue\t\tTotal Weight\t\tBenefit"<<endl;	for(i = 0; i < n; i++){		if(items[i].weight + totalWeight <= w){			totalWeight += items[i].weight;			totalBenefit += items[i].value;			cout<<"\t"<<items[i].id<<"\t\t"<<items[i].weight<<"\t\t"<<fixed<<setprecision(2)<<items[i].value<<"\t\t"<<totalWeight<<"\t\t\t"<<fixed<<setprecision(2)<<totalBenefit<<endl;		}else{			wt = (w - totalWeight);			value = wt * (float(items[i].value) / items[i].weight);			totalWeight += wt;			totalBenefit += value;			cout<<"\t"<<items[i].id<<"\t\t"<<wt<<"\t\t"<<fixed<<setprecision(2)<<value<<"\t\t"<<totalWeight<<"\t\t\t"<<fixed<<setprecision(2)<<totalBenefit<<endl;			break;		}	} cout<<endl;	cout<<"Total Weight: "<<totalWeight<<endl;	cout<<"Total Benefit: "<<fixed<<setprecision(2)<<totalBenefit<<endl;}void print(){	cout<<"\nFractional Knapsack:\n\n\tFractional Knapsack problem is a greedy algorithm. \n\tIt's objective is to fill the knapsack with items to get maximum benefit without crossing the weight capacity of knapsack."<<endl;	cout<<"\nProblem:\n\n\t1. A given knapsack has a maximum weight limit.\n\t2. Each items have weight and value associated with it.\n\t3. The solution have to maximize the benefit such that the total weight inside the knapsack is at most the limit.\n\t4. Taking an item in fractional part is allowed."<<endl;	cout<<"\nHow to Solve:\n\n\tAssume a knapsack with 6 items and max wight capacity 16.\n\tThe objective is to fill the knapsack with items such that the benefit is maximum.\n"<<endl;}int main(){	print();	int i, j;	Item items[6] = {		{"i1", 6, 6, 0},		{"i2", 10, 2, 0},		{"i3", 3, 1, 0},		{"i4", 5, 8, 0},		{"i5", 1, 3, 0},		{"i6", 3, 5, 0}	};	Item temp;	int n = 6;	int w = 16;	cout<<"Given Items & their associated Weight and Value:\n\n\tItem\tWeight\tValue"<<endl;	for(i = 0; i < n; i++){		items[i].density = float(items[i].value) / items[i].weight;		cout<<"\t"<<items[i].id<<"\t"<<items[i].weight<<"\t"<<items[i].value<<endl;	} cout<<endl;	cout<<"Step 1:\n\n\tNow we need to compute density = (value/weight)\n\nItems with Density:\n\n\tItem\tWeight\tValue\tDensity"<<endl;	for(i = 0; i < n; i++) cout<<"\t"<<items[i].id<<"\t"<<items[i].weight<<"\t"<<items[i].value<<"\t"<<fixed<<setprecision(2)<<items[i].density<<endl;	cout<<endl;	for(i = 1; i < n; i++){		for(j = 0; j < n - i; j++){			if(items[j+1].density > items[j].density){				temp = items[j+1];				items[j+1] = items[j];				items[j] = temp;			}		}	}	cout<<"Step 2:\n\n\tNow we need to sort the items as per the value density in descending order.\n\nItems as per Density in Descending Order:\n\n\tItem\tWeight\tValue\tDensity"<<endl;	for(i = 0; i < n; i++) cout<<"\t"<<items[i].id<<"\t"<<items[i].weight<<"\t"<<items[i].value<<"\t"<<fixed<<setprecision(2)<<items[i].density<<endl;	cout<<endl;	fractionalKnapsack(items, n, w);	return 0;}