#include<iostream>#include<stack>using namespace std;#define MAX 100#define visited 1int n;int adj[MAX][MAX];int state[MAX];void print();void printADJ();void create_graph();void DF_Traversal();void DFS(int v);int main(){	print();	create_graph();	printADJ();	DF_Traversal();	return 0;}void DF_Traversal(){	int v;	for(v=0; v<n; v++) state[v] = visited-1;	cout<<"Enter Start Vertex for DFS: ";	cin>>v;	DFS(v);}void DFS(int v){	int result[MAX];	int c = 0;	stack<int> stackk;	stackk.push(v);	cout<<"\n-------------------------------------------------------------------------------------------------\n";	while(!stackk.empty()){		v = stackk.top();		stackk.pop();		if(state[v]!=visited){			cout<<"\n\tNow we will search for all adjacent node for "<<v<<" and mark it as visited."<<endl;			result[c++] = v;			state[v] = visited;		}		cout<<"\tAs ";		int k = 0;		for(int i=0; i<n; i++){			if(adj[v][i]==1 && state[i]!=visited){				stackk.push(i);				cout<<i<<" ";				k++;			}		}		if(k==0) cout<<"nothing is adjacent to "<<v<<" and not visited yet, we move to the next."<<endl;		else cout<<"are adjacent to "<<v<<" and not visited yet, we add them to be visited next."<<endl;		cout<<endl;		stack<int> cpy = stackk;		cout<<"\t\tVisited Nodes: ";		for(int i=0;i<c;i++){			cout<<result[i]<<" ";		}		cout<<"\n\t\tStack: ";		if(cpy.empty()) cout<<"Empty";		while(!cpy.empty()){			cout<<cpy.top()<<" ";			cpy.pop();		}		cout<<"\n\n-------------------------------------------------------------------------------------------------\n";	}	cout<<"\n\n\t\t\tAs the stack is empty, our traversal ends here."<<endl;	cout<<"\n\t\t\tFollowing is the Depth First Traversal: ";	for(int i=0;i<c;i++){		cout<<result[i]<<" ";	}	cout<<"\n\n";}void create_graph(){	int count,max_edge,origin,destin;	cout<<"Enter Number of Vertex: ";	cin>>n;	cout<<endl;	max_edge = n*(n-1);	for(count=1; count<=max_edge; count++){		cout<<"Enter Edge "<<count<<"(-1 -1 to Quit): ";		cin>>origin>>destin;		if((origin == -1) && (destin == -1)) break;		else if(origin>=n || destin>=n || origin<0 || destin<0){			cout<<"Invalid Edge!"<<endl;			count--;		}else{			adj[origin][destin] = 1;		}	}}void printADJ(){	cout<<"\n\n\tThe Adjacency Matrix of the Graph is: \n\n\n\t\t\t";	for(int i=0; i<n;i++){		cout<<i<<"\t";	}	cout<<"\n"<<endl;	for(int i=0; i<n; i++){		cout<<"\t\t"<<i<<"\t";		for(int j=0; j<n; j++){			cout<<adj[i][j]<<"\t";		}		cout<<endl;	}	cout<<"\n"<<endl;}void print(){	cout<<"\n\n\t\t\t\tDepth First Search (DFS)"<<endl;	cout<<"\n\n\tThe DFS algorithm is a recursive algorithm that uses the idea of backtracking.\n\n\tIt involves exhaustive searches of all the nodes by going ahead, if possible else by backtracking."<<endl;	cout<<"\n\tAll the nodes will be visited on the current path till all the unvisited nodes have been traversed.\n\n\tAfter which the next path will be selected."<<endl;	cout<<"\n\tThis recursive nature of DFS can be implemented by using stacks."<<endl;	cout<<"\n\n\tThe basic Idea is as follows: "<<endl;	cout<<"\n\t\tPick a starting node and push all its adjacent nodes into a stack."<<endl;	cout<<"\n\t\tPop a node from stack to select the next node to visit and push all it's adjacent nodes into a stack."<<endl;	cout<<"\n\t\tRepeat this process until the stack i empty. However, ensure that the nodes that are visited are marked."<<endl;	cout<<"\n\nLet's have a live example of DFS Traversal: \n\n"<<endl;}